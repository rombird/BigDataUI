<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        // 배열 : 여러 자료 type을 저장하기 위한 자료구조
        // 서로 다른 type의 자료형도 한 배열안에 담을 수 있다
        let arr=['str1', "str2", `str3`, null, true, false, undefined, {name:"홍길동", age:15}];
        // console.log(arr);
        // console.log(typeof arr[0]);
        // console.log(typeof arr[1]);
        // console.log(typeof arr[2]);
        // console.log(typeof arr[3]);
        // console.log(typeof arr[4]);
        // console.log(typeof arr[5]);
        // console.log(typeof arr[6]);
        // console.log(typeof arr[7]);

        // arr[8] = 100;
        // // console.log(arr);
        // arr[10] = "HELLO WORLD";
        // console.log(arr);
        // // 9번 인덱스가 없어도 undefined로 지정돼서 저장됨
        // console.log(typeof arr[9], typeof arr[10]); 

        // 배열함수 : push. pop
        // arr.push('aaa');
        // arr.push('bbb');
        // arr.push('ccc');
        // console.log(arr);

        // pop을 먼저진행 후 console.log에 기록됨
        // arr.pop();
        // console.log(arr);
        // arr.pop();
        // console.log(arr);

        // 배열함수 : forEach(로직전달 가능함수 -> 콜백함수)
        // .forEach((item)=>{})
        // console.log("-------------------")
        // arr.forEach((item)=>{console.log('item', item);});

        // 이전 주석처리 후 진행
        // 정렬 : arr.sort(()=>{})
        // let arr2=[10, 55, 11, 25, 5, 44, 21, 8, 20];
        // console.log(arr2);
        // // 오름차순 정렬 - 문자열의 유니코드 코드 포인트 따름
        // arr2.sort();
        // console.log(arr2); // [10, 11, 20, 21, 25, 44, 5, 55, 8]
        // arr2.sort((a, b)=>{return a-b;});
        // console.log(arr2) // [5, 8, 10, 11, 20, 21, 25, 44, 55]

        // // 내림차순 정렬
        // arr2.sort((a, b)=>{return b-a;});
        // console.log(arr2); // [55, 44, 25, 21, 20, 11, 10, 8, 5]
        // arr2.sort((a, b)=>b-a);
        // console.log(arr2); // [55, 44, 25, 21, 20, 11, 10, 8, 5]

        // 필터 
        // let arr3=[11, 'str1', 22, "str2", 33, `str3`,10.5, null, true, false, undefined, 101, {name:"홍길동", age:15}];
        // number만 추출
        // let result = arr3.filter((item)=>{return typeof item=="number"});
        // console.log(result); // [11, 22, 33, 10.5, 101]
        // string만 추출
        // let result2 = arr3.filter((item)=>typeof item=="string");
        // console.log(result2); // ['str1', 'str2', 'str3']

        // 누산 : arr.reduce(()=>{}, 누산변수 초기값)
        // const sum = arr3.filter((item)=>{return typeof item=="number"}) // 숫자값만 필터
        //                 .reduce((sum, item)=>{return sum+item;}, 0) // 누적합 구하기
        // console.log(sum)

        // 배열object 처리 [{},{},{},{}...]
        // let arr5 = [
        //     {pid:"1",pname:"모니터",price:100,amount:50},
        //     {pid:"2",pname:"노트북",price:200,amount:15},
        //     {pid:"3",pname:"냉장고",price:250,amount:30},
        //     {pid:"4",pname:"데스크탑",price:70,amount:19},
        //     {pid:"5",pname:"가습기",price:10,amount:200},
        // ];
        // console.log(arr5);
        // // arr_5.forEach(item=>console.log(item));
        // arr5.forEach((item,index)=>{console.log(index, item);})

        // // 각 item의 가격이 100이상인 object만 필터링
        // arr5.forEach((item, index)=>{console.log(item["price"]);})
        // // const filter_01 = arr5.filter((item)=>{return item["price"]>=100;})
        // const filter_01 = arr5.filter(item=>item.price>=100);
        // console.log(filter_01);

        // // 각 아이템 수량이 30개 이하인 object만 필터링
        // const filter_02 = arr5.filter(item=>item.amount<=30);
        // console.log(filter_02);

        // // 각 아이템 가격이 100만원 이상인 item의 가격 총합(누적)을 구하시오.
        // const sum = arr5.filter(item=>item.price>=100)
        //                 .reduce((sum, item)=>{return sum+(item.price*item.amount);}, 0);
        // console.log('100만원 이상인 item의 price 누적합 : ', sum);


        // // 재구성배열.map(()=>{})
        // let arr6 = [
        //     { pid: "1", pname: "모니터", price: 100, amount: 50 },
        //     { pid: "2", pname: "노트북", price: 200, amount: 15 },
        //     { pid: "3", pname: "냉장고", price: 250, amount: 30 },
        //     { pid: "4", pname: "데스크탑", price: 70, amount: 19 },
        //     { pid: "5", pname: "가습기", price: 10, amount: 200 },
        // ];

        // // // arr6에 요소 추가 : totalprice : price*amount
        // let maped_01 = arr6.map((item) => {
        //     // 기존의 속성을 그대로 가져온다는 의미 : ...
        //     item={...item, "total_price":item.price*item.amount};
        //     console.log("!", item);
        //     return item; 
        // });
        // console.log(maped_01);

        // // // 수량이 30이상인 요소만 필터링해서 price가 낮은 값 우선 오름차순 / price*amount 항목 추가
        // const filter_a = arr6.filter(item=>item.amount>=30);
        // filter_a.sort((a,b)=>{return a.price-b.price;});

        // console.log("수량 30이상, price 오름차순 : ", filter_a);
        // let maped_02 = filter_a.map((item)=>{
        //     item={...item, "price*amount":item.price*item.amount};
        //     console.log("price*amount 추가 : ", item);
        //     return item;
        // });
        // // 답
        // const maped = arr6.filter((item)=>{return item.amount>=30;})
        //                      .sort((a, b)=>{return a.price-b.price;})
        //                      .map((item)=>{
        //                         item={...item, "price*amount":item.price*item.amount};    
        //                         return item;
        //                     })

        let employees = [
            { id: 1, name: "김철수", age: 35, department: "개발", salary: 6000, years: 10 },
            { id: 2, name: "이영희", age: 28, department: "디자인", salary: 5000, years: 5 },
            { id: 3, name: "박지성", age: 40, department: "마케팅", salary: 7000, years: 15 },
            { id: 4, name: "손흥민", age: 30, department: "개발", salary: 6500, years: 7 },
            { id: 5, name: "정우성", age: 45, department: "경영", salary: 9000, years: 20 },
            { id: 6, name: "한지민", age: 29, department: "디자인", salary: 5200, years: 6 },
            { id: 7, name: "강호동", age: 50, department: "경영", salary: 8500, years: 25 },
            { id: 8, name: "유재석", age: 42, department: "마케팅", salary: 7500, years: 18 },
            { id: 9, name: "송중기", age: 32, department: "개발", salary: 6200, years: 8 },
            { id: 10, name: "수지", age: 26, department: "디자인", salary: 4800, years: 3 }
        ];

        //연봉이(salary) 6000이상이면서 근속연수(years)가 7년이상인(item.salary>=6000 && item.years>=7) 직원만 필터링해서 배열로 저장 확인
        // const filter_01 = employees.filter((item)=>{return item.salary>=6000 && item.years>=7;});
        // console.log(filter_01);

        //모든 직원의 연봉(salary) 기준으로 내림차순 정렬한 배열 새로 만들기
        // const sort_01 = employees.sort((a, b)=>{return b.salary-a.salary;})
        // console.log(sort_01);

        //모든 직원의 연봉(salary) 에 근속연수*100 만큼의 보너스를 추가하여 total_salary필드를 추가한 배열을 반환
        // const maped_01 = employees.map((item)=>{
        //                                     item={...item, "total_salary":item.salary+(item.years*100)};
        //                                     return item;
        //                                 });
        // console.log(maped_01);

        //department(부서) 별로 직원들의 연봉총합을 구하세요
        // const depart1 = employees.filter((item)=>{return item.department=="개발";}).reduce((sum, item)=>{return sum+item.salary;}, 0);
        // console.log("개발직 연봉 총합 : ", depart1);
        
        // const depart2 = employees.filter(item=>item.department=="디자인").reduce((sum, item)=>{return sum+item.salary;}, 0);
        // console.log("디자인직 연봉 총합 : ", depart2);
        
        // const depart3 = employees.filter(item=>item.department=="마케팅").reduce((sum, item)=>{return sum+item.salary;}, 0);
        // console.log("마케팅직 연봉 총합 : ", depart3);

        // const depart4 = employees.filter(item=>item.department=="경영").reduce((sum, item)=>{return sum+item.salary;}, 0);
        // console.log("경영직 연봉 총합 : ", depart4);

        // 한번에 나타내기
        // sum[item.department]=0으로 해서 어떻게 작동하는지 보기
        // 분기 처리 : undefined?1:sum[item:department]+1 --> 정의된게 있으면 1, 
        // sum[item.department]=sum[item.department]==undefined?1:sum[item.department]+1;
        // const result4 = employees.reduce((sum, item)=>{
        //     sum[item.department]=sum[item.department]==undefined?item.salary:sum[item.department]+item.salary;
        //     console.log(sum);
        //     return sum;
        // },{})
        // console.log(result4);


        // // 연봉(salary)가 가장높은 직원을 찾아 객체하나만 반환(mdn문서에서 find를 찾아보세요 - !)
        // // 내 답
        // // function isHigh(num){
        // //     return num.salary >= 9000;
        // // }
        // // console.log(employees.find(isHigh));     
        
        // // 1번째 방법
        // const max_item = employees.sort((a,b)=>{return b.salary-a.salary;})[0];
        // console.log(max_item);

        // // 2번째 방법 - find쓰려면 최대값을 알아야 사용 가능
        // const max_item2 = employees.find((item)=>{return item.salary==max_item.salary;})
        // console.log(max_item2);
    </script>
</body>

</html>